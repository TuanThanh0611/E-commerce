"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GradleBuilder = void 0;
const constants_1 = require("../constants");
const builder_core_interface_1 = require("./builder-core.interface");
const utils_1 = require("../utils");
const path_1 = require("path");
const devkit_1 = require("@nx/devkit");
class GradleBuilder {
    constructor(commandAliases) {
        this.commandAliases = commandAliases;
    }
    getBuildSystemType() {
        return builder_core_interface_1.BuildSystem.GRADLE;
    }
    getExecutable(ignoreWrapper, useLegacyWrapper = false) {
        return ignoreWrapper ? constants_1.GRADLE_EXECUTABLE : constants_1.GRADLE_WRAPPER_EXECUTABLE;
    }
    getCommand(alias, options) {
        let additionalArgs = '';
        let cwd = options.cwd;
        if (!options.ignoreWrapper &&
            !(0, utils_1.hasGradleWrapper)(options.cwd) &&
            !options.runFromParentModule) {
            throw new Error(`⚠️ You chose not to use the Gradle wrapper from the parent module, but no wrapper was found in current child module`);
        }
        let pathToModule = [];
        if (options.runFromParentModule) {
            const childModuleName = (0, path_1.basename)(cwd);
            do {
                const module = (0, path_1.basename)(cwd);
                cwd = (0, path_1.resolve)(cwd, '..');
                pathToModule = [module, ...pathToModule];
            } while (!(0, utils_1.hasGradleModule)(cwd, childModuleName) && cwd !== devkit_1.workspaceRoot);
            additionalArgs = `${pathToModule.join(':')}`;
        }
        return {
            cwd,
            command: `${additionalArgs}${pathToModule.length ? ':' : ''}${this.commandAliases[alias]}`,
        };
    }
}
exports.GradleBuilder = GradleBuilder;
//# sourceMappingURL=gradle-builder.class.js.map