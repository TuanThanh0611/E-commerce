"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readXml = readXml;
exports.findXmlNodes = findXmlNodes;
exports.findXmlNode = findXmlNode;
exports.findNodeContent = findNodeContent;
exports.findXmlContent = findXmlContent;
exports.findXmlContents = findXmlContents;
exports.hasXmlMatching = hasXmlMatching;
exports.findXmlMatching = findXmlMatching;
exports.newXmlNode = newXmlNode;
exports.addXmlNode = addXmlNode;
exports.removeXmlNode = removeXmlNode;
exports.addXmlElement = addXmlElement;
exports.isXmlNodeEmpty = isXmlNodeEmpty;
const xmlbuilder2_1 = require("xmlbuilder2");
const xpath_1 = require("xpath");
function readXml(xmlContent, ignoreNamespace = true) {
    if (!xmlContent) {
        throw new Error('Cannot read XML, provided content is empty');
    }
    return (0, xmlbuilder2_1.create)(ignoreNamespace
        ? {
            defaultNamespace: {
                ele: null,
                att: null,
            },
        }
        : {}, xmlContent);
}
function findXmlNodes(xml, xpath, ignoreNamespace = true) {
    let realXpath = xpath;
    if (ignoreNamespace) {
        const prefix = xpath.startsWith('//') ? '//' : '/';
        realXpath =
            prefix +
                xpath
                    .split('/')
                    .filter((p) => p.length > 0)
                    .map((p) => p.trim() === '..'
                    ? p
                    : p
                        .trim()
                        .replace(/^([\w-.:]+)(?:\[[^]+\])?$/, `*[local-name(.) = '$1']`))
                    .join('/');
    }
    return (0, xpath_1.select)(realXpath, asXmlNode(xml));
}
function findXmlNode(xml, xpath, ignoreNamespace = true) {
    const nodes = findXmlNodes(xml, xpath, ignoreNamespace);
    return Array.isArray(nodes) ? nodes[0] : undefined;
}
function findNodeContent(source, xpath, ignoreNamespace = true) {
    return findXmlContent(asNewXMLBuilder(source), xpath, ignoreNamespace);
}
function findXmlContent(xml, xpath, ignoreNamespace = true) {
    const node = findXmlNode(xml, xpath, ignoreNamespace);
    if (isNode(node)) {
        return node.textContent;
    }
    return node?.toString();
}
function findXmlContents(xml, xpath, ignoreNamespace = true) {
    const nodes = findXmlNodes(xml, xpath, ignoreNamespace);
    if (Array.isArray(nodes)) {
        return nodes.map(n => n.textContent).filter(v => v !== null);
    }
    return [];
}
function hasXmlMatching(xml, xpath, ignoreNamespace = true) {
    const result = findXmlNodes(xml, xpath, ignoreNamespace);
    if (Array.isArray(result))
        return result?.length > 0;
    return !!result;
}
function findXmlMatching(xml, xpath, ignoreNamespace = true) {
    const value = findXmlNode(xml, xpath, ignoreNamespace);
    if (value) {
        return asXMLBuilder(value, ignoreNamespace);
    }
    return null;
}
function newXmlNode(content) {
    return (0, xmlbuilder2_1.create)(content);
}
function addXmlNode(target, node) {
    const child = newXmlNode(node);
    return target.import(child);
}
function removeXmlNode(nodeToRemove) {
    return nodeToRemove.remove();
}
function addXmlElement(target, ...elements) {
    let result = target;
    elements.forEach((elm) => {
        result =
            typeof elm === 'string'
                ? result.ele(elm)
                : result.ele(elm.name, elm.attributes);
    });
    return result;
}
function isXmlNodeEmpty(xml) {
    try {
        return !xml.first();
    }
    catch (error) {
        return true;
    }
}
function asNewXMLBuilder(node, ignoreNamespace = true) {
    return readXml((0, xmlbuilder2_1.builder)(node).toString(), ignoreNamespace);
}
function asXMLBuilder(node, ignoreNamespace = true) {
    return (0, xmlbuilder2_1.builder)(ignoreNamespace
        ? {
            defaultNamespace: {
                ele: null,
                att: null,
            },
        }
        : {}, node);
}
function asXmlNode(xml) {
    return xml.node;
}
function isNode(value) {
    return value?.nodeType !== undefined;
}
//# sourceMappingURL=xml-utils.js.map