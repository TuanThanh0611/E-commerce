"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDependenciesIf = exports.createNodesFor = void 0;
exports.getProjectGraph = getProjectGraph;
const devkit_1 = require("@nx/devkit");
const minimatch_1 = require("minimatch");
const utils_1 = require("./utils");
const path_1 = require("path");
function getPackageInfosForNxProjects(pluginName, projectFilter, getPackageInfo, workspace) {
    const workspacePackageInfo = {
        projects: {},
        packages: {},
    };
    Object.entries(workspace.projects)
        .filter(([, project]) => projectFilter(project))
        .forEach(([projectName, project]) => {
        try {
            const pkgInfo = getPackageInfo(project);
            workspacePackageInfo.projects[project.root] = pkgInfo;
            workspacePackageInfo.packages[pkgInfo.packageId] = projectName;
        }
        catch (e) {
            if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
                devkit_1.logger.warn(`[${pluginName}]: Failed to get package info for project '${projectName}'`);
                devkit_1.logger.warn(e);
            }
        }
    });
    return workspacePackageInfo;
}
function getDependenciesForProject(pluginName, filePath, sourceProjectName, workspace) {
    if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
        devkit_1.logger.debug(`[${pluginName}]: Getting dependencies for project '${sourceProjectName}'...`);
    }
    const dependencies = [];
    const sourceProjectRoot = (0, utils_1.getProjectRootFromFile)(filePath);
    const sourcePkgInfo = workspace.projects[sourceProjectRoot];
    if (!sourcePkgInfo)
        return dependencies;
    sourcePkgInfo.dependencies?.forEach((depPkgInfo) => {
        const targetProjectName = workspace.packages[depPkgInfo.packageId];
        if (targetProjectName) {
            dependencies.push({
                source: sourceProjectName,
                target: targetProjectName,
                type: devkit_1.DependencyType.static,
                sourceFile: (0, devkit_1.joinPathFragments)(sourceProjectRoot, sourcePkgInfo.packageFile),
            });
        }
    });
    sourcePkgInfo.modules?.forEach((moduleId) => {
        const depProject = workspace.projects[moduleId];
        if (depProject) {
            dependencies.push({
                source: sourceProjectName,
                target: workspace.packages[depProject.packageId],
                type: devkit_1.DependencyType.static,
                sourceFile: (0, devkit_1.joinPathFragments)(sourceProjectRoot, sourcePkgInfo.packageFile),
            });
        }
    });
    return dependencies;
}
function getProjectFilesGlob(projectFiles) {
    return projectFiles.length > 1
        ? `**/{${projectFiles.join(',')}}`
        : `**/${projectFiles[0]}`;
}
// Project Graph V1
function getProjectGraph(pluginName, projectFilter, getPackageInfo, graph, ctx) {
    const builder = new devkit_1.ProjectGraphBuilder(graph);
    if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
        devkit_1.logger.debug(`[${pluginName}]: Looking related projects inside the workspace...`);
    }
    let workspace = undefined;
    let dependencies = [];
    for (const source in ctx.filesToProcess) {
        const changed = ctx.filesToProcess[source];
        for (const file of changed) {
            // we only create the workspace map once and only if changed file is of interest
            workspace ??= getPackageInfosForNxProjects(pluginName, projectFilter, getPackageInfo, ctx.projectsConfigurations);
            dependencies = dependencies.concat(getDependenciesForProject(pluginName, file.file, source, workspace));
        }
    }
    for (const dep of dependencies) {
        builder.addDependency(dep.source, dep.target, dep.type, dep.source);
    }
    return builder.getUpdatedProjectGraph();
}
// Project Graph V2
const createNodesFor = (projectFiles, projectFilter, getProjectTypeAndTargets, pluginName) => [
    getProjectFilesGlob(projectFiles),
    (file, options, context) => {
        if (!projectFilter({ root: (0, utils_1.getProjectRootFromFile)(file) })) {
            return {}; // back off if the file/project does not match the criteria
        }
        const root = (0, path_1.dirname)(file);
        // eslint-disable-next-line no-useless-escape -- eslint's wrong
        const parts = root.split(/[\/\\]/g);
        const name = parts[parts.length - 1].toLowerCase();
        return {
            projects: {
                [name]: {
                    name,
                    root,
                    ...((0, utils_1.isNxCrystalEnabled)()
                        ? getProjectTypeAndTargets(file, options)
                        : {}),
                    tags: [`type:${pluginName.replace('@nxrocks/', '')}`],
                },
            },
        };
    },
];
exports.createNodesFor = createNodesFor;
const createDependenciesIf = (pluginName, projectFiles, projectFilter, getPackageInfo, ctx) => {
    if (process.env['NX_VERBOSE_LOGGING'] === 'true') {
        devkit_1.logger.debug(`[${pluginName}]: Looking related projects inside the workspace...`);
    }
    let workspace = undefined;
    let dependencies = [];
    const projectFileGlob = getProjectFilesGlob(projectFiles);
    for (const source in ctx.filesToProcess.projectFileMap) {
        const changed = ctx.filesToProcess.projectFileMap[source];
        for (const file of changed) {
            if ((0, minimatch_1.minimatch)(file.file, projectFileGlob)) {
                // we only create the workspace map once and only if changed file is of interest
                workspace ??= getPackageInfosForNxProjects(pluginName, projectFilter, getPackageInfo, { projects: ctx.projects });
                dependencies = dependencies.concat(getDependenciesForProject(pluginName, file.file, source, workspace));
            }
        }
    }
    dependencies.forEach((dep) => (0, devkit_1.validateDependency)(dep, ctx));
    return dependencies;
};
exports.createDependenciesIf = createDependenciesIf;
//# sourceMappingURL=project-graph.js.map